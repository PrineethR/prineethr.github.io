<!DOCTYPE html>
<html>
<head>
    <title>3D Landscape Recreation</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let trees = [];

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color('#4A3C2B');
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 6);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 1);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(5, 5, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Ground
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: '#3B2C1F',
                flatShading: true
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            // Path
            const pathShape = new THREE.Shape();
            pathShape.moveTo(-2, -5);
            pathShape.quadraticCurveTo(0, 0, 2, -5);
            const pathGeometry = new THREE.ShapeGeometry(pathShape);
            const pathMaterial = new THREE.MeshPhongMaterial({ 
                color: '#5C4033',
                flatShading: true
            });
            const path = new THREE.Mesh(pathGeometry, pathMaterial);
            path.rotation.x = -Math.PI / 2;
            path.position.y = 0.01;
            scene.add(path);

            // Trees (using custom geometry for a more stylized look)
            function createTree(x, z) {
                const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.3, 2, 6);
                const trunkMaterial = new THREE.MeshPhongMaterial({ 
                    color: '#2D231C',
                    flatShading: true 
                });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                
                const foliageGeometry = new THREE.ConeGeometry(1, 3, 6);
                const foliageMaterial = new THREE.MeshPhongMaterial({ 
                    color: '#2D231C',
                    flatShading: true 
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = 2;

                const tree = new THREE.Group();
                tree.add(trunk);
                tree.add(foliage);
                tree.position.set(x, 0, z);
                tree.castShadow = true;
                scene.add(tree);
                return tree;
            }

            // Add trees on both sides of the path
            trees.push(createTree(-2.5, -2));
            trees.push(createTree(2.5, -2));

            // Mountains in background
            const mountainGeometry = new THREE.ConeGeometry(2, 3, 4);
            const mountainMaterial = new THREE.MeshPhongMaterial({ 
                color: '#6B4C3D',
                flatShading: true 
            });
            const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
            mountain.position.set(0, 0, -5);
            scene.add(mountain);

            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Handle window resizing
        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>