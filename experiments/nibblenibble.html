<!DOCTYPE html>
<html lang="en">
  <head>
    <title>an uneasy sketch</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.1/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.1/addons/p5.sound.min.js"></script>
    <meta charset="utf-8" />
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background: #111;
        color: #fff;
      }
      .text-section {
        height: 50vh;
        padding: 2rem;
        max-width: 800px;
        margin: 0 auto;
      }
      h1 {
        font-size: 2.5rem;
        margin-bottom: 1.5rem;
      }
      p {
        font-size: 1.1rem;
        line-height: 1.6;
        margin-bottom: 1.5rem;
      }
      main {
        display: block;
        position: relative;
      }
      a {
    color: #87CEEB;  /* Light blue, matching your background */
    text-decoration: underline;
    opacity: 0.9;
    transition: opacity 0.2s ease;
}

a:hover {
    opacity: 1;
    color: white;
}
    </style>
  </head>
  <body>
    <div class="text-section">
      <h1>uneasy</h1>
      <p>i worked on this to try and simulate what makes me uneasy. is it the colors? is it the lack of smooth transitions? why do I feel this way?</p>
      <p>the color palettes draw inspiration from various sources: chrome reflections, psychadelic aesthetics, deep space phenomena, and the organic movement of fire. click anywhere to change the color scheme, or press 'r'</p>
    </div>
    <main>
    </main>
    <script>
// First, we need our vertex shader
const vertShader = `
attribute vec3 aPosition;
attribute vec2 aTexCoord;
varying vec2 vTexCoord;
void main() {
  vec4 positionVec4 = vec4(aPosition, 1.0);
  positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
  vTexCoord = aTexCoord;
  gl_Position = positionVec4;
}
`;

// Our enhanced fragment shader with multiple color schemes
const fragShader = `
precision highp float;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_seed;
uniform float u_time;

// Get colors based on palette index and position
vec3 getPaletteColor(float index, float position) {
    // Palette 1: Chrome
    if (index < 1.0) {
        if (position < 0.2) return vec3(0.02, 0.02, 0.02);  // Black
        if (position < 0.4) return vec3(0.85, 0.85, 0.95);  // Silver
        if (position < 0.6) return vec3(0.95, 0.35, 0.55);  // Pink
        if (position < 0.8) return vec3(0.95, 0.85, 0.2);   // Yellow
        return vec3(0.35, 0.65, 0.85);                      // Blue
    }
    // Palette 2: Cyberpunk
    else if (index < 2.0) {
        if (position < 0.2) return vec3(0.1, 0.0, 0.2);     // Deep Purple
        if (position < 0.4) return vec3(0.8, 0.2, 0.8);     // Magenta
        if (position < 0.6) return vec3(0.2, 0.8, 0.8);     // Cyan
        if (position < 0.8) return vec3(0.1, 0.9, 0.3);     // Neon Green
        return vec3(1.0, 0.4, 0.0);                         // Orange
    }
    // Palette 3: Deep Space
    else if (index < 3.0) {
        if (position < 0.2) return vec3(0.05, 0.0, 0.15);   // Deep Blue
        if (position < 0.4) return vec3(0.8, 0.0, 0.5);     // Hot Pink
        if (position < 0.6) return vec3(0.3, 0.0, 0.8);     // Purple
        if (position < 0.8) return vec3(0.0, 0.5, 1.0);     // Electric Blue
        return vec3(0.0, 1.0, 0.8);                         // Aqua
    }
    // Palette 4: Fire
    else {
        if (position < 0.2) return vec3(0.2, 0.0, 0.0);     // Dark Red
        if (position < 0.4) return vec3(1.0, 0.2, 0.0);     // Bright Red
        if (position < 0.6) return vec3(1.0, 0.8, 0.0);     // Gold
        if (position < 0.8) return vec3(1.0, 0.4, 0.0);     // Orange
        return vec3(0.8, 0.0, 0.2);                         // Ruby
    }
}

vec3 chromeColor(float t) {
    float paletteIndex = floor(mod(u_seed, 4.0));
    float p = fract(t * 2.0);
    
    vec3 color1 = getPaletteColor(paletteIndex, floor(p * 5.0) / 5.0);
    vec3 color2 = getPaletteColor(paletteIndex, ceil(p * 5.0) / 5.0);
    
    return mix(color1, color2, fract(p * 5.0));
}

float radialBurst(vec2 uv, float seed, float time) {
    vec2 center = vec2(0.0, 0.1);
    vec2 p = uv - center;
    
    float angle = atan(p.y, p.x);
    float dist = length(p);
    
    float burst = sin(angle * 8.0 + seed * 10.0 + time * 0.2) * 0.1;
    burst += cos(dist * 4.0 - angle * 2.0 + time * 0.1) * 0.2;
    burst += sin(dist * 1.0 + seed + time * 0.15) * 0.1;
    burst += sin(dist * 0.2 - seed + time * 0.05);
    
    float centerIntensity = smoothstep(0.4, 0.0, dist);
    burst *= mix(4.9, 2.0, centerIntensity);
    
    return burst;
}

void main() {
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.x, u_resolution.y);
    
    float pattern = radialBurst(uv, u_seed, u_time);
    vec3 color = chromeColor(pattern);
    
    float highlight = smoothstep(0.35, 0.65, pattern);
    color = mix(color, vec3(1.0), highlight * 0.35);
    
    float vignette = smoothstep(1.0, 0.3, length(uv));
    color *= mix(0.9, 1.0, vignette);
    
    gl_FragColor = vec4(color, 1.0);
}
`;

let myShader;
let seed = 0.0;
let time = 0.0;

function preload() {
    myShader = createShader(vertShader, fragShader);
}

function setup() {
    createCanvas(windowWidth, windowHeight, WEBGL);
    pixelDensity(1);
    noStroke();
    frameRate(60);
}

function draw() {
    time += deltaTime * 0.02;
    
    shader(myShader);
    
    myShader.setUniform('u_resolution', [width, height]);
    myShader.setUniform('u_mouse', [mouseX, mouseY]);
    myShader.setUniform('u_seed', seed);
    myShader.setUniform('u_time', time);
    
    rect(-width/2, -height/2, width, height);
}

function mousePressed() {
    seed = floor(random(512)) + random(2515830);
}

function windowResized() {
    resizeCanvas(windowWidth, windowHeight);
    pixelDensity(1);
}

function keyPressed() {
    if (key === 'r' || key === 'R') {
        time = 0.0;
        seed = random(2515830);
    }
}</script>
  </body>
</html>